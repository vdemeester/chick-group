#!/usr/bin/env nix-shell
#! nix-shell -i bash -p bash git nix-update jq nodejs prefetch-npm-deps curl

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Get the script directory
SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"
cd "$SCRIPTPATH"

# Function to print colored messages
info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Get all packages from the flake
get_all_packages() {
    nix eval --json '.#packages.x86_64-linux' --apply 'builtins.attrNames' 2>/dev/null | jq -r '.[]'
}

# Get packages that are tracked via git (have JSON files in repos/)
get_git_packages() {
    local git_packages=()
    for json_file in repos/*.json; do
        if [ -f "$json_file" ]; then
            # Extract package name from filename (e.g., deptree-main.json -> deptree)
            local pkg_name=$(basename "$json_file" | sed 's/-[^-]*\.json$//')
            git_packages+=("$pkg_name")
        fi
    done
    echo "${git_packages[@]}"
}

# Check if a package is git-tracked (either by name or by using a git-tracked repo JSON)
is_git_package() {
    local package=$1
    local git_packages=($(get_git_packages))

    # Check if package name matches a git repo name
    for git_pkg in "${git_packages[@]}"; do
        if [ "$git_pkg" = "$package" ]; then
            return 0
        fi
    done

    # Check if the package's nix file imports any git-tracked repo JSON
    local pkg_file="packages/${package}.nix"
    if [ -f "$pkg_file" ]; then
        for json_file in repos/*.json; do
            if [ -f "$json_file" ]; then
                local json_basename=$(basename "$json_file")
                if grep -q "$json_basename" "$pkg_file" 2>/dev/null; then
                    return 0
                fi
            fi
        done
    fi

    return 1
}

# Check if a package is an npm package (uses buildNpmPackage)
is_npm_package() {
    local package=$1
    local pkg_file="packages/${package}.nix"
    [ -f "$pkg_file" ] && grep -q -w "buildNpmPackage" "$pkg_file" 2>/dev/null
}

# Update npm package with two-phase approach:
# Phase 1: Update version and src hash with nix-update
# Phase 2: Regenerate package-lock.json and update npmDepsHash
update_npm_package() {
    local package=$1
    local pkg_file="packages/${package}.nix"

    info "Updating npm package $package (two-phase approach)..."

    # Phase 1: Run nix-update to update version and src hash (no commit yet)
    info "Phase 1: Updating version and src hash..."
    if ! nix-update --flake "$package"; then
        warn "No update available for $package or nix-update failed"
        return 1
    fi

    # Get the new version from the nix file
    local new_version
    new_version=$(grep -oP 'version = "\K[^"]+' "$pkg_file" | head -1)
    info "New version: $new_version"

    # Phase 2: Generate new package-lock.json
    info "Phase 2: Regenerating package-lock.json for version $new_version..."

    # Create a temporary directory for npm operations
    local tmpdir
    tmpdir=$(mktemp -d)
    # Cleanup function for this tmpdir
    cleanup_tmpdir() { rm -rf "$tmpdir"; }

    # Get the npm package name from the nix file (extract from URL or pname)
    local npm_package_name
    npm_package_name=$(grep -oP 'registry\.npmjs\.org/\K@?[^/]+(/[^/]+)?' "$pkg_file" | head -1)
    if [ -z "$npm_package_name" ]; then
        # Fallback to pname
        npm_package_name=$(grep -oP 'pname = "\K[^"]+' "$pkg_file" | head -1)
    fi
    info "npm package name: $npm_package_name"

    # Download and extract the package to get package.json
    local tarball_url="https://registry.npmjs.org/${npm_package_name}/-/${package}-${new_version}.tgz"
    info "Downloading from: $tarball_url"

    # Try different URL patterns (some packages have different naming)
    if ! curl -sL "$tarball_url" | tar -xz -C "$tmpdir" 2>/dev/null; then
        # Try with the full npm package name (for scoped packages)
        local pkg_basename
        pkg_basename=$(echo "$npm_package_name" | sed 's/@[^/]*\///')
        tarball_url="https://registry.npmjs.org/${npm_package_name}/-/${pkg_basename}-${new_version}.tgz"
        info "Retrying with: $tarball_url"
        if ! curl -sL "$tarball_url" | tar -xz -C "$tmpdir" 2>/dev/null; then
            error "Failed to download package tarball"
            cleanup_tmpdir
            return 1
        fi
    fi

    # Find the extracted package directory
    local pkg_dir
    pkg_dir=$(find "$tmpdir" -maxdepth 1 -type d -name "package" | head -1)
    if [ -z "$pkg_dir" ]; then
        pkg_dir="$tmpdir/package"
    fi

    if [ ! -f "$pkg_dir/package.json" ]; then
        error "package.json not found in extracted tarball"
        cleanup_tmpdir
        return 1
    fi

    # Generate package-lock.json
    info "Running npm install --package-lock-only..."
    (cd "$pkg_dir" && npm install --package-lock-only --ignore-scripts 2>/dev/null) || {
        error "Failed to generate package-lock.json"
        cleanup_tmpdir
        return 1
    }

    if [ ! -f "$pkg_dir/package-lock.json" ]; then
        error "package-lock.json was not generated"
        cleanup_tmpdir
        return 1
    fi

    # Copy the new package-lock.json to our repo
    cp "$pkg_dir/package-lock.json" "packages/package-lock.json"
    info "Updated packages/package-lock.json"

    # Calculate the new npmDepsHash
    info "Calculating new npmDepsHash..."
    local new_hash
    new_hash=$(prefetch-npm-deps "packages/package-lock.json" 2>/dev/null)
    if [ -z "$new_hash" ]; then
        error "Failed to calculate npmDepsHash"
        cleanup_tmpdir
        return 1
    fi
    info "New npmDepsHash: $new_hash"

    # Cleanup temp directory now that we're done with it
    cleanup_tmpdir

    # Update the npmDepsHash in the nix file
    sed -i "s|npmDepsHash = \"sha256-[^\"]*\"|npmDepsHash = \"$new_hash\"|" "$pkg_file"

    # Commit all changes together
    info "Committing changes..."
    git add "$pkg_file" "packages/package-lock.json"
    git commit -m "${package}: update to ${new_version}

- Updated version and src hash
- Regenerated package-lock.json
- Updated npmDepsHash"

    info "Successfully updated $package to $new_version"
    return 0
}

# Function to update packages using nix-update
update_with_nix_update() {
    local package=$1
    info "Updating $package with nix-update..."

    # For npm packages, use the two-phase approach
    if is_npm_package "$package"; then
        info "Detected npm package, using two-phase update"
        update_npm_package "$package"
        return $?
    fi

    # For non-npm packages, use standard nix-update
    if nix-update --flake --commit "$package"; then
        info "Successfully updated $package"
        return 0
    else
        warn "Failed to update $package with nix-update"
        return 1
    fi
}

# Function to update packages from git repos
update_from_git() {
    local specific_packages=("$@")
    local git_packages=($(get_git_packages))

    if [ ${#git_packages[@]} -eq 0 ]; then
        info "No git-tracked packages found"
        return 0
    fi

    info "Updating packages from git repositories: ${git_packages[*]}..."

    if ./repos/update; then
        info "Successfully updated git-tracked packages"
        return 0
    else
        error "Failed to update git-tracked packages"
        return 1
    fi
}

# Main update logic
main() {
    local packages_to_update=("$@")
    local all_packages=($(get_all_packages))
    local git_packages=($(get_git_packages))

    info "Found packages in flake: ${all_packages[*]}"
    info "Git-tracked packages: ${git_packages[*]}"

    # If no packages specified, update all
    if [ ${#packages_to_update[@]} -eq 0 ]; then
        info "No specific packages specified, updating all packages..."

        # First, update git-tracked packages
        if [ ${#git_packages[@]} -gt 0 ]; then
            update_from_git
        fi

        # Then update packages that can use nix-update
        for package in "${all_packages[@]}"; do
            if ! is_git_package "$package"; then
                info "Updating $package with nix-update..."
                update_with_nix_update "$package" || true
            fi
        done

        info "All package updates completed"
    else
        # Update specific packages
        local git_packages_to_update=()
        local nix_packages_to_update=()

        for package in "${packages_to_update[@]}"; do
            # Check if package exists in flake
            local package_exists=false
            for flake_pkg in "${all_packages[@]}"; do
                if [ "$flake_pkg" = "$package" ]; then
                    package_exists=true
                    break
                fi
            done

            if [ "$package_exists" = false ]; then
                error "Unknown package: $package"
                error "Available packages: ${all_packages[*]}"
                exit 1
            fi

            # Categorize package
            if is_git_package "$package"; then
                git_packages_to_update+=("$package")
            else
                nix_packages_to_update+=("$package")
            fi
        done

        # Update git-tracked packages
        if [ ${#git_packages_to_update[@]} -gt 0 ]; then
            info "Updating git-tracked packages: ${git_packages_to_update[*]}"
            update_from_git "${git_packages_to_update[@]}"
        fi

        # Update nix-update packages
        for package in "${nix_packages_to_update[@]}"; do
            update_with_nix_update "$package"
        done
    fi
}

# Run main function with all arguments
main "$@"
